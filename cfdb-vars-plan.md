# cfdb-vars Implementation Plan

## Problem

Adding a new variable to cfdb requires editing four places in the cfdb package:

1. `default_dtype_params` dict in `utils.py` — encoding (precision, offset, dtype, fillvalue)
2. `default_var_params` dict in `utils.py` — display name and optional axis
3. `default_attrs` dict in `utils.py` — CF attributes (long_name, units, standard_name, etc.)
4. `@create_data_var_methods(var_names=(...))` decorator in `creation.py` — register the method name

This forces a cfdb release for every new variable, even though cfdb's engine code doesn't change.

## Solution

Create a new `cfdb-vars` package that:

- Defines a msgspec `VariableSpec` Struct (the data model)
- Contains all variable definitions as `VariableSpec` instances in a Python module
- Provides a registry dict and a `register()` function for runtime extension
- Is consumed by cfdb (engine) and can be consumed by cfdb-ingest or any other package

## Current Data Flow

```
cfdb_name string (e.g. 'air_temp')
  │
  ▼
getattr(ds.create.data_var, 'air_temp')   ← generated by @create_data_var_methods
  │
  ▼
utils.get_var_params('air_temp', kwargs)
  ├── default_dtype_params['air_temp']  →  dtype/encoding params
  ├── default_var_params['air_temp']    →  display_name='air_temperature'
  └── default_attrs['air_temp']         →  CF attributes dict
  │
  ▼
DataVar.generic('air_temperature', coords, dtype=DataType(...), chunk_shape=...)
  │
  ▼
data_var.attrs.update({long_name, units, standard_name, ...})
```

Key detail: the short name (e.g. `air_temp`) is the dict key and method name. The display name (e.g. `air_temperature`) from `default_var_params` is what gets stored in the cfdb file.

---

## Phase 1: Create cfdb-vars package

### 1.1 Package structure

```
cfdb-vars/
├── pyproject.toml          # hatchling build, msgspec dependency only
├── cfdb_vars/
│   ├── __init__.py         # exports VariableSpec, VARIABLES, register()
│   ├── models.py           # msgspec Struct definition
│   └── variables.py        # all VariableSpec instances
```

### 1.2 Data model (`models.py`)

```python
import msgspec
from typing import Any

class VariableSpec(msgspec.Struct, frozen=True):
    """Metadata specification for a cfdb variable (coordinate or data variable)."""
    name: str                                # short name / registry key, e.g. 'air_temp'
    display_name: str                        # storage name in cfdb file, e.g. 'air_temperature'
    dtype: str                               # decoded dtype, e.g. 'float32', 'datetime64[m]', 'uint8'
    dtype_encoded: str | None = None         # encoded dtype, e.g. 'uint16', 'int32'
    precision: int | None = None             # decimal precision for encoding
    offset: float | int | None = None        # encoding offset
    fillvalue: int | None = None             # fill value for encoded dtype
    axis: str | None = None                  # for coordinates: 'x', 'y', 'z', 't', 'xy'
    attrs: dict[str, Any] = {}               # CF attributes: long_name, units, standard_name, flags, etc.
```

The `attrs` dict provides the flexibility to store any CF or custom metadata attributes without changing the model. Flag values, flag meanings, custom metadata — all go here.

Using `frozen=True` makes specs hashable and immutable (prevents accidental mutation of shared definitions).

### 1.3 Variable definitions (`variables.py`)

One dict of `VariableSpec` instances, organized with comments by category. Contains both coordinates and data variables:

```python
from cfdb_vars.models import VariableSpec

VARIABLES: dict[str, VariableSpec] = {}

def _register(*specs: VariableSpec):
    for spec in specs:
        VARIABLES[spec.name] = spec

# --- Coordinates ---
_register(
    VariableSpec(
        name='lat',
        display_name='latitude',
        dtype='float64',
        dtype_encoded='uint32',
        precision=6,
        offset=-180.000001,
        fillvalue=0,
        axis='y',
        attrs={
            'long_name': 'latitude',
            'units': 'degrees_north',
            'standard_name': 'latitude',
            'axis': 'Y',
        },
    ),
    # ... all other coordinates ...
)

# --- Atmospheric variables ---
_register(
    VariableSpec(
        name='air_temp',
        display_name='air_temperature',
        dtype='float32',
        dtype_encoded='uint16',
        precision=2,
        offset=-61,
        fillvalue=0,
        attrs={
            'long_name': 'air temperature',
            'units': 'K',
            'standard_name': 'air_temperature',
        },
    ),
    # ... all other data variables ...
)
```

### 1.4 Registry and public API (`__init__.py`)

```python
from cfdb_vars.models import VariableSpec
from cfdb_vars.variables import VARIABLES

def register(spec: VariableSpec) -> None:
    """Register a variable spec at runtime. Overwrites existing entries with the same name."""
    VARIABLES[spec.name] = spec

def get(name: str) -> VariableSpec:
    """Look up a variable spec by short name. Raises KeyError if not found."""
    return VARIABLES[name]
```

### 1.5 Complete variable inventory to migrate

**Coordinates** (from `@create_coord_methods` + the three dicts):
`time`, `lat`, `lon`, `height`, `altitude`, `x`, `y`, `point`, `line`, `polygon`

Also in `default_dtype_params` but not in the decorator:
`modified_date`, `band`, `censor_code`

**Data variables** (from `@create_data_var_methods` + the three dicts):
`precip`, `air_temp`, `wind_speed`, `wind_direction`, `u_wind`, `v_wind`,
`relative_humidity`, `dew_temp`, `soil_temp`, `lwe_soil_moisture`,
`surface_pressure`, `mslp`, `specific_humidity`, `mixing_ratio`,
`shortwave_radiation`, `longwave_radiation`, `snow_depth`, `vorticity`,
`vertical_velocity`, `sensible_heat_flux`, `moisture_flux`, `albedo`,
`emissivity`, `terrain_height`, `potential_temperature`,
`equivalent_potential_temperature`, `land_use_modis`

---

## Phase 2: Refactor cfdb to consume cfdb-vars

### 2.1 Add cfdb-vars as a dependency

In `cfdb/pyproject.toml`, add `cfdb-vars` to dependencies.

### 2.2 Replace `get_var_params` in `utils.py`

Replace the function that reads from three dicts with one that reads from a `VariableSpec`:

```python
from cfdb_vars import get as get_variable_spec

def get_var_params(name, kwargs=None):
    if kwargs is None:
        kwargs = {}

    spec = get_variable_spec(name)

    # Build dtype from spec (unless caller overrides)
    if 'dtype' not in kwargs:
        dtype_kwargs = {'name': spec.dtype}
        if spec.dtype_encoded is not None:
            dtype_kwargs['dtype_encoded'] = spec.dtype_encoded
        if spec.precision is not None:
            dtype_kwargs['precision'] = spec.precision
        if spec.offset is not None:
            dtype_kwargs['offset'] = spec.offset
        if spec.fillvalue is not None:
            dtype_kwargs['fillvalue'] = spec.fillvalue
        kwargs['dtype'] = dtypes.dtype(**dtype_kwargs)
    elif not isinstance(kwargs['dtype'], dtypes.DataType):
        kwargs['dtype'] = dtypes.dtype(kwargs.pop('dtype'))

    var_params = dict(kwargs)
    var_name = spec.display_name
    attrs = dict(spec.attrs)

    return var_name, var_params, attrs
```

### 2.3 Replace the `@create_data_var_methods` decorator with `__getattr__`

Replace the hardcoded variable list in the decorator with dynamic lookup:

```python
class DataVar:
    def __init__(self, dataset):
        self._dataset = dataset

    def __getattr__(self, name):
        try:
            spec = cfdb_vars.get(name)
        except KeyError:
            raise AttributeError(f"'{type(self).__name__}' has no variable '{name}'")

        # Only allow data variables (no axis field) through this path
        if spec.axis is not None:
            raise AttributeError(f"'{name}' is a coordinate, not a data variable")

        def method(coords, **kwargs):
            var_name, var_params, attrs = utils.get_var_params(name, kwargs)
            data_var = self.generic(var_name, coords, **var_params)
            data_var.attrs.update(attrs)
            return data_var

        method.__name__ = name
        return method

    def generic(self, name, coords, **kwargs):
        # ... existing implementation unchanged ...
```

Same approach for `Coord`:

```python
class Coord:
    def __getattr__(self, name):
        try:
            spec = cfdb_vars.get(name)
        except KeyError:
            raise AttributeError(f"'{type(self).__name__}' has no variable '{name}'")

        def method(**kwargs):
            var_name, var_params, attrs = utils.get_var_params(name, kwargs)
            coord = self.generic(var_name, **var_params)
            coord.attrs.update(attrs)
            return coord

        method.__name__ = name
        return method
```

This eliminates the decorator entirely. Any variable in the cfdb-vars registry is automatically available as a method.

### 2.4 Remove the three dicts and dead code from `utils.py`

Delete:
- `default_dtype_params` dict
- `default_var_params` dict
- `default_attrs` dict
- `get_dtype_params` function (dead code, never called)
- `time_dtype_params` dict (fold into cfdb-vars `time` VariableSpec)

### 2.5 Remove the decorator definitions from `creation.py`

Delete:
- `make_inner_data_var_method` function
- `create_data_var_methods` function
- `make_inner_coord_method` function
- `create_coord_methods` function
- Both `@create_*_methods(var_names=(...))` decorator applications

---

## Phase 3: Update cfdb-ingest

### 3.1 No changes needed to `_create_cfdb_data_var`

The existing code in `base.py` uses `getattr(creator, cfdb_name)` which will now hit `DataVar.__getattr__` instead of a pre-generated method. The behavior is identical — no changes required.

### 3.2 Optional: register cfdb-ingest-specific variables

If cfdb-ingest ever needs variables that don't belong in the standard cfdb-vars catalog, it can register them at import time:

```python
from cfdb_vars import VariableSpec, register

register(VariableSpec(
    name='some_wrf_specific_var',
    display_name='some_wrf_specific_variable',
    dtype='float32',
    ...
))
```

Currently all WRF variables use standard meteorological names that belong in cfdb-vars, so this isn't needed yet.

---

## Phase 4: Testing

### 4.1 cfdb-vars tests

- Each `VariableSpec` in `VARIABLES` has required fields populated
- No duplicate `name` values
- No duplicate `display_name` values
- `register()` adds to registry and overwrites correctly
- `get()` returns correct spec and raises `KeyError` for unknown names
- All specs are valid msgspec Structs (frozen, serializable)

### 4.2 cfdb tests

- Existing test suite passes unchanged (the API is the same: `ds.create.data_var.air_temp(...)`)
- `__getattr__` returns a callable for known variables
- `__getattr__` raises `AttributeError` for unknown variables
- Runtime-registered variables are accessible via `__getattr__`
- `DataVar.__getattr__` rejects coordinate names, `Coord.__getattr__` rejects data variable names

### 4.3 cfdb-ingest tests

- Existing 72 tests pass unchanged

---

## Dependency Graph

```
cfdb-vars  (msgspec only)
     │
     ├──── cfdb  (depends on cfdb-vars)
     │       │
     │       └──── cfdb-ingest  (depends on cfdb)
     │
     └──── (any future ingest package can also depend on cfdb-vars directly)
```

---

## Implementation Order

1. Create cfdb-vars package with model and all variable definitions
2. Write cfdb-vars tests
3. Refactor cfdb to depend on cfdb-vars, replace dicts/decorator with `__getattr__` + registry lookup
4. Run cfdb tests — should pass unchanged
5. Update cfdb-ingest dependency (add cfdb-vars if needed, though it comes transitively via cfdb)
6. Run cfdb-ingest tests — should pass unchanged
7. Release cfdb-vars, then cfdb, then cfdb-ingest
